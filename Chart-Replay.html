<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> TA Intuition Builder For Security Prices </title>
    <style>
        :root {
            --bg-color: #131722;
            --grid-color: #2a2e39;
            --text-color: #d1d4dc;
            --bull-color: #089981;
            --bear-color: #f23645;
            --accent-color: #2962ff;
            --panel-bg: #1e222d;
        }
        input:focus, select:focus, textarea:focus, button:focus { outline:0 }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none; /* Prevent text selection during drag */
            touch-action: none; /* Prevent browser handling of gestures */
        }

        /* --- Toolbar --- */
        .toolbar {
            padding: 4px;
            background-color: #031b5c63;
            border: solid 2px #04348f;
            margin: 2px;
            border-radius: 10px;
            z-index: 20;
            font-family: Arial, Courier, monospace, sans-serif;
            font-size: 12px;
            font-weight: 600;
        }

        ::placeholder {
            color: #929292;
            font-size: 14px;
            font-weight: 600;
        }

        button, input[type="file"], input[type="text"], #max-candles-input {
            background: #031547be;
            color: #ece919;
            margin: 2px;
            border: 2px dashed #bb550d;
            padding: 6px 9px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
        }
        button:hover { background: #363a45; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        #btn-ai {
            background: linear-gradient(140deg, #912e2e, #022e6e);
            border: 2px solid #bb550d;
            font-weight: bold;
            border-radius: 4px;
        }
        #btn-ai:hover { background: linear-gradient(140deg, #02364b, #793c04); }

        /* Custom Slider Styling */
        .slider {
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 4px 8px;
            margin: 2px;
        }
        
        input[type="range"] {
            background: transparent;
            width: 70vw;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            background: #434651; border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px; width: 14px;
            border-radius: 50%; background: var(--accent-color);
            margin-top: -5px; cursor: pointer;
        }

        label { 
            color: #c2bebe; 
            font-size: 14px; 
            text-transform: uppercase; 
            font-weight: 600;
        }

        .selectOptions {
            font-weight: 600;
            color: #b4b4b4;
            border: 2px dotted #555;
            border-radius: 4px;
            background-color: #02121b;
            width: 90px;
            padding: 2px;
        }

        #hamburgerMenu {
            position: absolute;
            bottom: 10px;
            z-index: 100;
            right: 10px;
            font-size: 14px;
            font-weight: 1000;
            transition: transform 0.4s ease;
            color: #e2df12;
            border: 2px solid #7c7676;
            border-radius: 50px;
            background-color: #470505b4;
        }

        /* --- Main Layout --- */
        #main-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* --- Y-Axis (Left Side) --- */
        #price-scale {
            width: 16vw;
            background-color: var(--panel-bg);
            border-right: 2px solid var(--grid-color);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            z-index: 10;
            cursor: ns-resize;
            touch-action: none;
        }

        /* Static Label Containers */
        .static-label {
            position: absolute;
            right: 0;
            width: 100%;
            height: 0; /* Height 0, we position the border and text */
            border-top: 1px solid #2a2e39; /* Grid line extension */
        }
        .static-label span {
            position: absolute;
            right: 6px;
            top: -8px; /* Center text on line */
            font-size: 11px;
            color: #888;
        }

        /* --- Chart Area --- */
        #chart-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair; /* Default cursor */
            background-color: var(--bg-color);
            touch-action: none; /* Disable browser scrolling */
        }
        
        /* Cursor changes based on state */
        #chart-area.dragging { cursor: grabbing; }

        #candles-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Horizontal Grid Lines (inside chart area) */
        .grid-line {
            position: absolute;
            left: 0; width: 100%; height: 1px;
            background-color: #4b4d07;
            pointer-events: none;
        }

        /* Center Line & Current Price Label */
        #center-line {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #2962ff66;
            border-top: 1px dashed #2962ffe6;
            pointer-events: none;
            z-index: 5;
            display: none; 
        }

        #current-price-badge {
            position: absolute;
            left: 0; 
            transform: translateY(-50%);
            background-color: var(--accent-color);
            color: white;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            border-radius: 0 3px 3px 0;
            z-index: 15;
            display: none;
        }

        /* --- Candle Styling --- */
        .candle {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        .wick { width: 1px; background-color: currentColor; position: absolute; }
        .body { width: 100%; position: absolute; border: 1px solid currentColor; box-sizing: border-box; }

        .bullish { color: var(--bull-color); }
        .bullish .body { background-color: rgba(8, 153, 129, 0.5); }
        
        .bearish { color: var(--bear-color); }
        .bearish .body { background-color: rgba(242, 54, 69, 0.5); }

        /* --- Modal --- */
        #ai-modal {
            display: none;
            position: fixed; z-index: 100; left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(3px);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background: #1e222d;
            border: 1px solid #434651;
            width: 90%; max-width: 600px; max-height: 80vh;
            border-radius: 8px;
            display: flex; flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .modal-header {
            padding: 15px; border-bottom: 1px solid #2a2e39;
            display: flex; justify-content: space-between;
        }
        .modal-body { padding: 20px; overflow-y: auto; line-height: 1.5; }
        .close-btn { background: none; border: none; font-size: 20px; padding: 0; color: #888; }
        
        .loading { text-align: center; color: var(--accent-color); font-style: italic; }
    </style>
</head>
<body>

    <div id="main-container">
        <!-- Left Y-Axis -->
        <div id="price-scale">
            <div id="current-price-badge">0.00</div>
            <!-- Static labels generated by JS -->
        </div>
        
        <!-- Chart Area -->
        <div id="chart-area">
            <div id="center-line"></div>
            <div id="candles-container"></div>
            <!-- Grid lines generated by JS -->
        </div>
    </div>
    <div id="jsonSettings" class="toolbar" style="gap: 4px; display: none">

        <select id="selectSymbol" class="selectOptions" onchange=" state.jsonSettings.symbol = this.value">
            <option value="BTCUSD">BTC USD (Bitcoin)</option>
            <option value="ETHUSD">ETH USD (Ethereum)</option>
            <option value="LTCUSD">LTC USD (Litecoin)</option>
            <option value="XRPUSD">XRP USD (Ripple)</option>
        </select>

        <select id="selectResolution" class="selectOptions" onchange="state.jsonSettings.resolution = this.value">
            <option value="1_Min">1 Minute</option>
            <option value="5_Min">5 Minutes</option>
            <option value="15_Min">15 Minutes</option>
            <option value="60_Min">1 Hour</option>
            <option value="240_Min">4 Hours</option>
            <option value="1440_Min">1 Day</option>
        </select>

        <select id="selectDuration" class="selectOptions" onchange="state.jsonSettings.duration = +this.value">
            <option value="43200">12 Hours</option>
            <option value="86400">1 Day</option>
            <option value="432000">5 Days</option>
            <option value="864000">10 Days</option>
            <option value="1296000">15 Days</option>
            <option value="2592000">30 Days</option>
        </select>

    </div>
    <div id="toolbar" class="toolbar">
        <div style="display: flex; flex-direction: row; align-items: center; gap: 10px">
          <input type="file" id="fileInput" accept=".json" style="width: 68vw; display: none" />
          <input id="urlInput" style="width: 70vw; padding: 9px; border: 2px dashed #bb550d" type="text" placeholder="Enter JSON URL..." />
          <button onclick="urlOrFile(); style.transform = (style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)')" style="transition: transform 0.4s ease" >☰</button>
        </div>
        <button id="btn-ai">AI Analyst</button>
        <input type="number" id="max-candles-input" style="width: 40px; padding: 6px 2px" min="50" value="500">

        <button id="btn-reset">RESET</button>
        <button id="btn-play">PLAY</button>
        
        <div class="slider">
            <label>Speed</label> 
            <input type="range" id="speed-slider" min="0" max="100" value="50">
        </div>
        <span id="status-text" style="margin-left : 10px; color: #b8b4b4; font-size: 14px;">No Data</span>
    </div>

    <!-- Hamburger Menu -->
    <button id="hamburgerMenu" onclick="toggleToolbar(); style.transform = (style.transform === 'rotate(180deg)' ? 'rotate(0deg)' : 'rotate(180deg)');">☰</button>
        
    <!-- AI Modal -->
    <div id="ai-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0; color:#fff;">AI Market Analysis</h3>
                <button class="close-btn" onclick="document.getElementById('ai-modal').style.display='none'">&times;</button>
            </div>
            <div class="modal-body" id="ai-result"></div>
        </div>
    </div>

    <script>
        // --- Global State ---
        const state = {
            // Data
            rawTicks: [],
            processedCandles: [],
            currentCandle: null,
            tickIndex: 0,
            jsonSettings: { symbol: 'BTCUSD', resolution: '1_Min', duration: 43200 },
            
            // Playback
            isPlaying: false,
            msDelay: 0,
            ticksPerFrame: 1,
            lastFrameTime: 0,
            
            // Viewport & Scale
            // viewPrice: Price at the exact vertical center of the canvas
            viewPrice: 0,
            // viewXOffset: Horizontal offset in pixels. 0 means "latest candle is at default position".
            viewXOffset: 0,
            
            candleWidth: 12,
            candleGap: 4,
            // pixelsPerPrice: Vertical Zoom Level
            pixelsPerPrice: 10,
            
            // Data Snapshots
            currentPrice: 0,       
            currentTime: 0,
            
            // Interaction State
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            
            // DOM Optimization
            maxCandlesInDom: 500
        };

        // --- DOM Elements ---
        const els = {
            chartArea: document.getElementById('chart-area'),
            candlesDiv: document.getElementById('candles-container'),
            priceScale: document.getElementById('price-scale'),
            centerLine: document.getElementById('center-line'),
            priceBadge: document.getElementById('current-price-badge'),
            status: document.getElementById('status-text'),
            btnPlay: document.getElementById('btn-play'),
            btnReset: document.getElementById('btn-reset'),
            btnAI: document.getElementById('btn-ai'),
            maxCandlesInput: document.getElementById('max-candles-input'),
            aiModal: document.getElementById('ai-modal'),
            aiResult: document.getElementById('ai-result')
        };

        // --- Data Generation ---
        function generateMockTicks(count = 5000) {
            let price = 1000;
            const ticks = [];
            let time = new Date().setHours(9, 30, 0, 0);
            for (let i = 0; i < count; i++) {
                price += (Math.random() - 0.5) * 2;
                time += Math.floor(Math.random() * 1000) + 100;
                ticks.push({ time, price: parseFloat(price.toFixed(2)) });
            }
            return ticks;
        }

        // Initial Load
        state.rawTicks = generateMockTicks();
        els.status.textContent = `Loaded ${state.rawTicks.length} Ticks (Mock).`;
        initializeView(state.rawTicks[0].price);

        function initializeView(startPrice) {
            state.viewPrice = startPrice;
            // Requirement: Top to Bottom is 10% of Price
            // Height / pixelsPerPrice = 0.10 * Price
            // pixelsPerPrice = Height / (0.10 * Price)
            const h = els.chartArea.clientHeight;
            if (startPrice > 0 && h > 0) {
                state.pixelsPerPrice = h / (startPrice * 0.1);
            } else {
                state.pixelsPerPrice = 50; // Fallback
            }
        }

        // --- Core Logic: Tick Processing ---
        function processTick(tick) {
            state.currentPrice = tick.price;
            state.currentTime = tick.time;

            const candleRes = Number( state.jsonSettings.resolution.split('_')[0] );
            const candleTimestamp = Math.floor(tick.time / (60000 * candleRes) ) * (60000 * candleRes);

            if (!state.currentCandle) {
                state.currentCandle = { time: candleTimestamp, open: tick.price, high: tick.price, low: tick.price, close: tick.price };
            } else if (candleTimestamp > state.currentCandle.time) {
                state.processedCandles.push(state.currentCandle);
                state.currentCandle = { time: candleTimestamp, open: tick.price, high: tick.price, low: tick.price, close: tick.price };
            } else {
                state.currentCandle.high = Math.max(state.currentCandle.high, tick.price);
                state.currentCandle.low = Math.min(state.currentCandle.low, tick.price);
                state.currentCandle.close = tick.price;
            }
            state.tickIndex++;
            els.status.innerHTML = `${state.tickIndex} / ${state.rawTicks.length} <span style="color: #239ef0; font-weight: 700"> ● ${state.processedCandles.length + 1} Candles ● </span> <span style="color: #fff222; font-weight: 700"> ${Math.round(state.tickIndex / state.rawTicks.length * 100)} % </span>`;
        }

        // --- Rendering System ---
        
        // Y = Height/2 + (CenterPrice - Price) * Scale (Standard coordinate system where Y=0 is top)
        // Correct logic for Y grows Down:
        // Price > Center -> Y < Center (Up)
        // Y = CenterPixel - (Price - CenterPrice) * Scale
        function getY(price, height) {
            const centerY = height / 2;
            const diff = price - state.viewPrice;
            return centerY - (diff * state.pixelsPerPrice);
        }

        function getPriceFromY(y, height) {
            const centerY = height / 2;
            // Y = Cy - (P - C) * S
            // Y - Cy = - (P - C) * S
            // (Cy - Y) / S = P - C
            // P = C + (Cy - Y) / S
            return state.viewPrice + (centerY - y) / state.pixelsPerPrice;
        }

        function renderStaticGrid(height) {
            const stepPixels = 60; // Distance between lines
            
            // Clear old grid/labels
            els.priceScale.querySelectorAll('.static-label').forEach(e => e.remove());
            els.chartArea.querySelectorAll('.grid-line').forEach(e => e.remove());

            // We need to find the price at the top (y=0) and loop down
            // But to keep grid lines "stable" while panning, we should snap to round numbers or fixed intervals relative to view
            // For simplicity in this demo, we just draw lines relative to screen pixels 
            // but calculated to represent price.
            
            // Simple approach: Draw lines at fixed pixel intervals from center
            const centerY = height / 2;
            
            // Go Up from Center
            for (let y = centerY; y >= 0; y -= stepPixels) {
                drawGridLine(y, height);
            }
            // Go Down from Center
            for (let y = centerY + stepPixels; y <= height; y += stepPixels) {
                drawGridLine(y, height);
            }
        }

        function drawGridLine(y, height) {
            const price = getPriceFromY(y, height);
            
            const label = document.createElement('div');
            label.className = 'static-label';
            label.style.top = `${y}px`;
            label.innerHTML = `<span>${price.toFixed(2)}</span>`;
            els.priceScale.appendChild(label);

            const grid = document.createElement('div');
            grid.className = 'grid-line';
            grid.style.top = `${y}px`;
            els.chartArea.appendChild(grid);
        }

        function renderChart() {
            if (state.currentPrice === 0) return;

            const width = els.chartArea.clientWidth;
            const height = els.chartArea.clientHeight;
            
            // 1. Grid
            renderStaticGrid(height);

            // 2. Current Price Line (Badges)
            const currentPriceY = getY(state.currentPrice, height);
            
            els.centerLine.style.display = 'block';
            els.centerLine.style.top = `${currentPriceY}px`;
            
            els.priceBadge.style.display = 'block';
            els.priceBadge.textContent = state.currentPrice.toFixed(2);
            els.priceBadge.style.top = `${currentPriceY}px`;

            // 3. Candles
            els.candlesDiv.innerHTML = '';
            const fragment = document.createDocumentFragment();

            const allCandles = [...state.processedCandles];
            if (state.currentCandle) allCandles.push(state.currentCandle);

            let renderList = allCandles;
            const maxLimit = state.maxCandlesInDom || 10000;
            if (allCandles.length > maxLimit) {
                renderList = allCandles.slice(-maxLimit);
            }

            // Position Logic
            // The "Latest" candle default position is around 80% width.
            // viewXOffset adjusts this.
            // If viewXOffset = 0, latest is at 90%.
            // If viewXOffset > 0, we moved candles Right (latest is further right/offscreen)
            // If viewXOffset < 0, we moved candles Left (looking at history)
            
            const baseHeadX = width * 0.9;
            const headX = baseHeadX + state.viewXOffset;
            const step = state.candleWidth + state.candleGap;

            for (let i = renderList.length - 1; i >= 0; i--) {
                const candle = renderList[i];
                const indexOffset = (renderList.length - 1) - i;
                const x = headX - (indexOffset * step);

                if (x > width + state.candleWidth) continue;
                if (x < -state.candleWidth) break;

                const yOpen = getY(candle.open, height);
                const yClose = getY(candle.close, height);
                const yHigh = getY(candle.high, height);
                const yLow = getY(candle.low, height);

                const isBull = candle.close >= candle.open;
                
                const el = document.createElement('div');
                el.className = `candle ${isBull ? 'bullish' : 'bearish'}`;
                el.style.left = `${x}px`;
                el.style.width = `${state.candleWidth}px`;
                el.style.height = "100%"; 
                el.style.top = "0";

                const wick = document.createElement('div');
                wick.className = 'wick';
                wick.style.top = `${Math.min(yHigh, yLow)}px`;
                wick.style.height = `${Math.abs(yLow - yHigh)}px`;
                wick.style.left = '50%';

                const body = document.createElement('div');
                body.className = 'body';
                const bodyTop = Math.min(yOpen, yClose);
                const bodyH = Math.max(1, Math.abs(yOpen - yClose));
                body.style.top = `${bodyTop}px`;
                body.style.height = `${bodyH}px`;

                el.appendChild(wick);
                el.appendChild(body);
                fragment.appendChild(el);
            }
            els.candlesDiv.appendChild(fragment);
        }

        // --- Loop ---
        function loop(timestamp) {
            if (!state.isPlaying) return;

            const elapsed = timestamp - state.lastFrameTime;

            if (elapsed >= state.msDelay) {
                for (let i = 0; i < state.ticksPerFrame; i++) {
                    if (state.tickIndex >= state.rawTicks.length) {
                        state.isPlaying = false;
                        els.btnPlay.textContent = "DONE";
                        return;
                    }
                    processTick(state.rawTicks[state.tickIndex]);
                }
                state.lastFrameTime = timestamp;
                renderChart();
            }
            requestAnimationFrame(loop);
        }

        // --- Interaction: Controls ---

        els.btnPlay.addEventListener('click', async function() {
            const jsonLink = document.getElementById('urlInput').value;
            if (jsonLink) {
                await fetchJsonData();
                return;
            }
            if (state.tickIndex >= state.rawTicks.length) {
                // Restart logic
                state.tickIndex = 0;
                state.processedCandles = [];
                state.currentCandle = null;
                state.currentPrice = 0;
                initializeView(state.rawTicks[0].price);
            }
            
            state.isPlaying = !state.isPlaying;
            this.textContent = state.isPlaying ? "STOP" : "PLAY";
            
            if (state.isPlaying) {
                // If playing, we generally want to snap to latest, but user requested independent Y.
                // We reset X offset to 0 to follow the candle building? 
                // Usually "Play" implies follow mode for X.
                state.viewXOffset = 0; 
                state.lastFrameTime = performance.now();
                loop(performance.now());
            } else {
                renderChart();
            }
        });

        els.btnReset.addEventListener('click', function() {
            state.isPlaying = false;
            state.tickIndex = 0;
            state.processedCandles = [];
            state.currentCandle = null;
            state.currentPrice = 0;
            state.viewXOffset = 0;
            els.btnPlay.textContent = "PLAY";
            els.candlesDiv.innerHTML = '';
            els.status.textContent = "Reset";
            
            if (state.rawTicks.length > 0) {
                initializeView(state.rawTicks[0].price);
            }
            renderChart();
        });

        document.getElementById('speed-slider').addEventListener('input', function(e) {
            const val = parseInt(e.target.value);
            if (val > 50) {
                state.msDelay = 0;
                state.ticksPerFrame = Math.max(1, val - 49);
            } else {
                state.ticksPerFrame = 1;
                state.msDelay = (50 - val) * 20; 
            }
        });

        els.maxCandlesInput.addEventListener('change', (e) => {
            const val = parseInt(e.target.value);
            state.maxCandlesInDom = val > 0 ? val : 10000;
            if (!state.isPlaying) renderChart();
        });

        // --- Interaction: Chart Area Pan & Zoom ---

        // Double Click to Recenter Price.
        els.chartArea.addEventListener('dblclick', () => {
             state.viewPrice = state.currentPrice;
             state.viewXOffset = 0;
             renderChart();
        });

        // Mouse Wheel (Zoom X)
        els.chartArea.addEventListener('wheel', (e) => {
            e.preventDefault();
            const dir = Math.sign(e.deltaY); // +1 down, -1 up
            const zoomFactor = 1.1;
            
            if (dir < 0) {
                // Zoom In
                state.candleWidth *= zoomFactor;
            } else {
                // Zoom Out
                state.candleWidth /= zoomFactor;
            }
            
            // Minimal safety check so it doesn't disappear
            if (state.candleWidth < 0.5) state.candleWidth = 0.5;
            state.candleGap = state.candleWidth / 3;
            
            renderChart();
        }, { passive: false });


        // Drag Logic (Chart Area)
        const chartTouch = { active: false, lastX: 0, lastY: 0, initialDist: 0, initialWidth: 0 };

        els.chartArea.addEventListener('mousedown', (e) => {
            chartTouch.active = true;
            chartTouch.lastX = e.clientX;
            chartTouch.lastY = e.clientY;
            els.chartArea.classList.add('dragging');
        });

        window.addEventListener('mousemove', (e) => {
            if (!chartTouch.active) return;
            
            const dx = e.clientX - chartTouch.lastX;
            const dy = e.clientY - chartTouch.lastY;

            // X Pan: Simply add pixels to offset
            state.viewXOffset += dx;

            // Y Pan: "Drag the paper".
            // If I drag mouse down (+dy), I am pulling the paper down.
            // The price at the viewport center should INCREASE (we are seeing higher prices that were above).
            // Wait, coordinate system: Y=0 is Top. Y increases down.
            // Price at Top is High. Price at Bottom is Low.
            // If I drag DOWN, I want to see what is ABOVE the viewport (Higher prices).
            // So ViewPrice should Increase.
            
            // Let's verify:
            // Mouse moves down +10px.
            // View should shift so that pixels move down +10px.
            // A candle at Y=100 should move to Y=110.
            // OldY = C - (P - VP_old)*S
            // NewY = C - (P - VP_new)*S
            // NewY - OldY = (VP_new - VP_old) * S
            // 10 = dVP * S => dVP = 10 / S.
            // So ViewPrice += dy / pixelsPerPrice.
            
            state.viewPrice += dy / state.pixelsPerPrice;

            chartTouch.lastX = e.clientX;
            chartTouch.lastY = e.clientY;
            renderChart();
        });

        window.addEventListener('mouseup', () => {
            chartTouch.active = false;
            els.chartArea.classList.remove('dragging');
        });

        // Touch - Chart Area (Pan & Pinch)
        function getDist(t1, t2) {
            return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        }

        els.chartArea.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                chartTouch.active = true;
                chartTouch.lastX = e.touches[0].clientX;
                chartTouch.lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                chartTouch.active = false; // Stop panning
                chartTouch.initialDist = getDist(e.touches[0], e.touches[1]);
                chartTouch.initialWidth = state.candleWidth;
            }
        }, { passive: false });

        els.chartArea.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (e.touches.length === 1 && chartTouch.active) {
                const dx = e.touches[0].clientX - chartTouch.lastX;
                const dy = e.touches[0].clientY - chartTouch.lastY;
                
                state.viewXOffset += dx;
                state.viewPrice += dy / state.pixelsPerPrice;
                
                chartTouch.lastX = e.touches[0].clientX;
                chartTouch.lastY = e.touches[0].clientY;
                renderChart();
            } else if (e.touches.length === 2) {
                const dist = getDist(e.touches[0], e.touches[1]);
                if (dist > 10 && chartTouch.initialDist > 10) {
                    const scale = dist / chartTouch.initialDist;
                    state.candleWidth = chartTouch.initialWidth * scale;
                    if (state.candleWidth < 0.5) state.candleWidth = 0.5;
                    state.candleGap = state.candleWidth / 3;
                    renderChart();
                }
            }
        }, { passive: false });

        els.chartArea.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) chartTouch.active = false;
        });

        // --- Interaction: Price Scale Zoom (Vertical) ---

        const scaleDrag = { active: false, lastY: 0 };

        function handleScaleStart(y) {
            scaleDrag.active = true;
            scaleDrag.lastY = y;
        }

        function handleScaleMove(y) {
            if (!scaleDrag.active) return;
            const dy = y - scaleDrag.lastY;
            // Drag Down (+dy) -> Zoom Out (Smaller Scale)
            // Drag Up (-dy) -> Zoom In (Larger Scale)
            
            // Sensitivity
            const sensitivity = 0.01; 
            const zoomChange = 1 - (dy * sensitivity);
            
            state.pixelsPerPrice *= zoomChange;
            if (state.pixelsPerPrice < 0.0001) state.pixelsPerPrice = 0.0001;

            scaleDrag.lastY = y;
            renderChart();
        }

        els.priceScale.addEventListener('mousedown', e => handleScaleStart(e.clientY));
        window.addEventListener('mousemove', e => { if (scaleDrag.active) handleScaleMove(e.clientY); });
        window.addEventListener('mouseup', () => scaleDrag.active = false);

        els.priceScale.addEventListener('touchstart', e => {
            e.preventDefault();
            if(e.touches.length === 1) handleScaleStart(e.touches[0].clientY);
        }, { passive: false });
        els.priceScale.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 1) handleScaleMove(e.touches[0].clientY);
        }, { passive: false });
        els.priceScale.addEventListener('touchend', () => scaleDrag.active = false);


        // --- Resize ---
        window.addEventListener('resize', () => renderChart());

        // --- File/AI Handlers (Existing) ---
        
        // File Input
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const json = JSON.parse(evt.target.result);
                    if (Array.isArray(json) && json.length > 0 && json[0].price !== undefined) {
                        state.rawTicks = json.sort((a,b) => a.time - b.time);
                        state.tickIndex = 0;
                        state.processedCandles = [];
                        state.currentCandle = null;
                        state.isPlaying = false;
                        els.btnPlay.textContent = "PLAY";
                        els.status.textContent = `Loaded ${state.rawTicks.length} Ticks From JSON File.`;
                        initializeView(state.rawTicks[0].price);
                        renderChart();
                    } else {
                        alert("Invalid JSON. Expected array of {time, price} objects.");
                    }
                } catch (err) {
                    alert("Error parsing JSON.");
                }
            };
            reader.readAsText(file);
        });

        // AI
        let apiKey = '';
        async function callGemini(aiPrompt) {
            apiKey = !apiKey ? prompt('Enter Gemini API Key:') : apiKey;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent`;
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'x-goog-api-key': apiKey, 'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: aiPrompt }] }] })
                });
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (e) {
                console.error(e);
                return "Error connecting to AI.";
            }
        }

        els.btnAI.addEventListener('click', async function() {
            if (state.processedCandles.length < 30) {
                alert("Please play the simulation longer to generate enough candle(30 or more) data.");
                return;
            }
            state.isPlaying = false;
            els.btnPlay.textContent = "PLAY";
            els.aiModal.style.display = 'flex';
            els.aiResult.innerHTML = '<div class="loading">Analyzing market structure...</div>';

            const history = state.processedCandles.slice(-30);
            const dataStr = history.map((c, i) => 
                `CDL${i}: O:${c.open.toFixed(2)} H:${c.high.toFixed(2)} L:${c.low.toFixed(2)} C:${c.close.toFixed(2)}`
            ).join('\n');

            const aiPrompt = `
                You are a veteran trader. Analyze this tick-replay data (last 30 candles).
                Current Price: ${state.currentPrice.toFixed(2)}
                Data: ${dataStr}
                Output format:
                <strong>Trend:</strong> [Bullish/Bearish]
                <strong>Levels:</strong> [Support/Resistance]
                <strong>Insight:</strong> [Patterns like Engulfing, Hammer, Double Top etc.]
                <strong>Prediction:</strong> [Short term bias]
            `;

            const text = await callGemini(aiPrompt);
            const markdown = text.replace(/\n/g, '<br>');
            els.aiResult.innerHTML = simpleMarkdownToHTML(markdown);
        });

        function simpleMarkdownToHTML(markdown) {
        const html = markdown.replace(/\*\*(.+?)\*\*/g, '<b>$1</b>')
            .replace(/\*(.+?)\*/g, '<i>$1</i>')
            .replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>')
            .replace(/^- (.+)$/gm, '<li>$1</li>')
            .replace(/(<li>[\s\S]+?<\/li>)/g, '<ul>$1</ul>')
            .replace(/^---+$/gm, '<hr>')
            .replace(/\n(?!<\/?ul>|<\/?li>)/g, '<br>');
            return html;
        }

        function toggleToolbar() {
            const toolbar = document.getElementById('toolbar');
            const status = toolbar.style.display;
            toolbar.style.display = status === 'none' ? 'block' : 'none';
        }
        
        function urlOrFile() {
            const urlInput = document.getElementById('urlInput');
            const fileInput = document.getElementById('fileInput');
            const jsonSettings = document.getElementById('jsonSettings');
            const urlVisible = urlInput.style.display;
            
            if (urlVisible === 'none') {
                fileInput.style.display = 'none';
                urlInput.style.display = 'block';
                jsonSettings.style.display = 'none';
            } else {
                urlInput.style.display = 'none';
                fileInput.style.display = 'block';
                jsonSettings.style.display = 'block';
            }
        }

        async function fetchJsonData() {
            const urlInput = document.getElementById('urlInput');
            const { symbol, resolution: res, duration } = state.jsonSettings;
            const resolution = +res.split('_')[0];
            const linksArray = [];
            const parts = Math.ceil(duration / (60 * 2000)); // Delta exchange API has a limit of 2000 candles per request. And only 1 minute (60s) resolution candles (lowest available) are being fetched to increase number of ticks per candle resulting in increased price action.
            let start = Math.round(Date.now() / 1000) - duration, end = 0;
            const nowTime = Math.round(Date.now() / 1000);
            for (let i = 1; i <= parts; i++) {
                const tempEnd = start + ( 60 * 2000 );
                end = tempEnd < nowTime ? tempEnd : nowTime;
                const url = urlInput.value.startsWith('https://api.india.delta.exchange/v2/history/candles') ? urlInput.value : `https://api.india.delta.exchange/v2/history/candles?resolution=1m&symbol=${symbol}&start=${start}&end=${end}`;
                linksArray.push(url);
                start = end;
            }
            const responses = await Promise.all( linksArray.map(url => fetch(url)) );
            const jsons = await Promise.all(responses.map( async res => (await res.json()).result ));
            const json = jsons.flat();
            const ticks = [];
            for (const candle of json) {
                const { time, open, high, low, close } = candle;
                const nearestToClose = Math.abs(close - high) < Math.abs(close - low) ? high : low;
                const t1 = time + 20, t2 = time + 40;
                ticks.push({ time: time * 1000, price: open }, { time: t1 * 1000, price: high === nearestToClose ? low : high}, { time: t2 * 1000, price: nearestToClose });
            }
            state.rawTicks = ticks.toSorted((a,b) => a.time - b.time);
            state.tickIndex = 0;
            state.processedCandles = [];
            state.currentCandle = null;
            state.isPlaying = false;
            els.btnPlay.textContent = "PLAY";
            els.status.textContent = `Loaded ${state.rawTicks.length} Ticks From JSON Link.`;
            initializeView(state.rawTicks[0].price);
            renderChart();
            urlInput.value = '';
            els.btnPlay.click();
        }

        async function saveChart() {
            const timePeriod = '', symbol = '', resolution = '', remarks = '';
            const json = JSON.stringify(state.processedCandles);
        }

        // Start.
        renderChart();

    </script>
</body>
</html>
